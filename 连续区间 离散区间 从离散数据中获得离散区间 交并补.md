---
tags: [interval, math, mathematica, sympy, wolfram]
title: 连续区间 离散区间 从离散数据中获得离散区间 交并补
created: '2022-08-22T14:30:28.000Z'
modified: '2022-08-22T20:00:47.952Z'
---

# 连续区间 离散区间 从离散数据中获得离散区间 交并补

离散区间的获得可以用边界条件判定 即最近n个连续的概率大于多少 容忍值为多少 最近n个小于多少直接作为结束边界的条件 也可以用convlution Gaussian blur

离散区间交并补可以转化为连续区间交并补 更简单省事

如果要做下面的运算 建议用第三方库 比如wolfram swi-prolog的clpr sympy

连续区间交并补 先排序 设置首末端的操作 然后进行相应区间选取 进行下一步操作直到结束 输出总的结果

sympy seems to provide support for discrete and continuous interval? will that save any damn time anyway? i'm afraid no? maybe there's a way!

first combine all intervals in same set:
```bash
mSet = [(0,1), (2,3)]
import sympy
for start, end in mSet:
  if mUncertain is None:
    mUncertain = sympy.Interval(start,end)
  else:
    mUncertain += sympy.Interval(start,end)
typeUncertain = type(mUncertain)
# can be either sympy.sets.sets.Interval of sympy.sets.sets.Union
```

next let's get all sub-intervals!
```bash
# hypothetical mSet2 and mUncertain2!

def checkCommon(subInterval, masterInterval):
  return subInterval == sympy.Intersection(subInterval, masterInterval)

mUncertains = [mUncertain, mUncertain2]
subIntervals = list(set(unrolledMSet2 + unrolledMSet))
subIntervals.sort()

subIntervals = zip(subIntervals[:-1], subIntervals[1:])
# for subIntervals, it's still not real interval but tuple at above line.

reversedCats = {}

for subIntervalIndex, (start, end) in enumerate(subIntervals):
  subIntervalCandidate = sympy.Interval(start, end)
  reverseIndex = [] # there must be at least one such index.
  for index, uncertainCandidate in enumerate(mUncertains):
    if checkCommon(subIntervalCandidate, uncertainCandidate):
      reverseIndex.append(index) # this is the index of the in-common set of the original set list
  reversedCats.update({subIntervalIndex:reverseIndexTuple}) # need to sort and index? or not to sort because this is already done?

normalCats = {}
for k,v in reversedCats.items():
  normalCats.update({v:normalCats.get(v, [])+[k]})
# we only get interval, not the actural union period!
```
